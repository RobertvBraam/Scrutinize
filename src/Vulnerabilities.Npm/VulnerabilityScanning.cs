using System.Diagnostics;
using System.Text.Json;
using Domain.Models;
using Domain.Results;

namespace Vulnerabilities.Npm;

public class VulnerabilityScanning : IVulnerabilities
{
    private readonly bool _isWindows;
    public VulnerabilityScanning(bool isWindows)
    {
        _isWindows = isWindows;
    }

    public Result<List<Vulnerability>> Scan(string sourcePath)
    {
        if (!Directory.Exists(sourcePath))
        {
            return Result<List<Vulnerability>>.Failed(InitializationFailed.Create());
        }

        var processStartInfo = new ProcessStartInfo
        {
            FileName = _isWindows ? "cmd" : "/bin/bash",
            WorkingDirectory = sourcePath,
            RedirectStandardInput = true,
            RedirectStandardOutput = false,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        var process = Process.Start(processStartInfo)!;
        // execute npm in a different directory
        process.StandardInput.WriteLine(@"npm i");
        process.StandardInput.WriteLine(
            @"npm audit --registry=https://registry.npmjs.org/ --json > npmVulnerabilities.json");
        process.StandardInput.WriteLine("exit");
        process.WaitForExit();

        var fileStream = File.OpenText(sourcePath + "/npmVulnerabilities.json");
        var records = JsonSerializer.Deserialize<NpmVulnerabilities>(fileStream.ReadToEnd(), new JsonSerializerOptions()
        {
            PropertyNameCaseInsensitive = true
        });
        var vulnerabilities = records.ToVulnerabilities().ToList();

        return Result<List<Vulnerability>>.Succeeded(vulnerabilities);
    }

    public class NpmVulnerability
    {
        public string Name { get; set; }
        public string Severity { get; set; }
        public List<JsonElement> Via { get; set; }
    }

    public class NpmVulnerabilities
    {
        public int AuditReportVersion { get; set; }
        public Dictionary<string, NpmVulnerability> Vulnerabilities { get; set; }

        public IEnumerable<Vulnerability> ToVulnerabilities()
        {
            foreach ((string dependencyName, NpmVulnerability vulnerability) in Vulnerabilities)
            {
                foreach (var element in vulnerability.Via)
                {
                    if (element.ValueKind == JsonValueKind.Object)
                    {
                        var dependency = element.Deserialize<Dependency>(new JsonSerializerOptions(){PropertyNameCaseInsensitive = true});
                        yield return new Vulnerability()
                        {
                            DependencyName = dependencyName,
                            Severity = vulnerability.Severity,
                            Source = dependency.Url
                        };
                    }
                }
            }
        }
    }

    public class Dependency
    {
        public string Name { get; set; }
        public string Url { get; set; }
        public string Severity { get; set; }
    }
}