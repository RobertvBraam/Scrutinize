using System.Diagnostics;
using System.Text.Json;
using Domain.Models;
using Domain.Results;

namespace Vulnerabilities.Npm;

public class VulnerabilityScanning : IVulnerabilities
{
    private readonly bool _isWindows;
    private const string Filename = "npmVulnerabilities.json";

    public VulnerabilityScanning(bool isWindows)
    {
        _isWindows = isWindows;
    }

    public Result<List<Vulnerability>> Scan(string sourcePath)
    {
        if (!Directory.Exists(sourcePath))
        {
            return Result<List<Vulnerability>>.Failed(InitializationFailed.Create());
        }
        var filePath = $"{sourcePath}/{Filename}";
        var process = StartCmdProcess(sourcePath);
        
        process.StandardInput.WriteLine("npm i");
        process.StandardInput.WriteLine($"npm audit --registry=https://registry.npmjs.org/ --json > {filePath}");
        process.StandardInput.WriteLine("exit");
        process.WaitForExit();

        if (File.Exists(filePath))
        {
            var fileStream = File.OpenText(filePath);
            var records = JsonSerializer.Deserialize<NpmVulnerabilities>(fileStream.ReadToEnd(), new JsonSerializerOptions()
            {
                PropertyNameCaseInsensitive = true
            });
            var vulnerabilities = records?.ToVulnerabilities().ToList() ?? new List<Vulnerability>();

            return Result<List<Vulnerability>>.Succeeded(vulnerabilities);
        }
        
        return Result<List<Vulnerability>>.Failed(InitializationFailed.Create());
    }

    private Process StartCmdProcess(string processDirectory)
    {
        var processStartInfo = new ProcessStartInfo
        {
            FileName = _isWindows ? "cmd" : "/bin/bash",
            WorkingDirectory = processDirectory,
            RedirectStandardInput = true,
            RedirectStandardOutput = false,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        var process = Process.Start(processStartInfo)!;
        return process;
    }
}