using System.Diagnostics;
using System.Text.Json;
using Domain.Dependencies;
using Domain.Results;
using Domain.Vulnerabilities;

namespace Scanning.Nuget.Vulnerabilities;

/// <summary>
/// Run this command to generate a report of all vulnerabilities in the project:
/// "dotnet list package --include-transitive --vulnerable --format json >> vulnerability.json"
/// </summary>
public class VulnerabilityScanning : IVulnerabilities
{
    private readonly bool _isWindows;
    private const string Filename = "nugetVulnerabilities.json";

    public VulnerabilityScanning(bool isWindows)
    {
        _isWindows = isWindows;
    }
    
    public Result<List<Dependency>> Scan(string sourcePath)
    {
        if (!Directory.Exists(sourcePath))
        {
            return Result<List<Dependency>>.Failed(InitializationFailed.Create());
        }
        
        var filePath = $"{sourcePath}/{Filename}";
        var process = StartCmdProcess(sourcePath);
        
        process.StandardInput.WriteLine("dotnet restore");
        process.StandardInput.WriteLine($"dotnet list package --include-transitive --vulnerable --format json > {filePath}");
        process.StandardInput.WriteLine("exit");
        process.WaitForExit();

        if (File.Exists(filePath))
        {
            var fileStream = File.OpenText(filePath);
            var records = JsonSerializer.Deserialize<RootAnalysis>(fileStream.ReadToEnd(), new JsonSerializerOptions()
            {
                PropertyNameCaseInsensitive = true
            });
            var dependencies = records?.ToDependencies() ?? new List<Dependency>();

            return Result<List<Dependency>>.Succeeded(dependencies);
        }
        
        return Result<List<Dependency>>.Failed(InitializationFailed.Create());
    }

    private Process StartCmdProcess(string processDirectory)
    {
        var processStartInfo = new ProcessStartInfo
        {
            FileName = _isWindows ? "cmd" : "/bin/bash",
            WorkingDirectory = processDirectory,
            RedirectStandardInput = true,
            RedirectStandardOutput = false,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        var process = Process.Start(processStartInfo)!;
        return process;
    }
}