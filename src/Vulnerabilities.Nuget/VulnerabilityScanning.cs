using System.Diagnostics;
using System.Text.Json;
using System.Text.Json.Serialization;
using Domain.Models;
using Domain.Results;

namespace Vulnerabilities.Nuget;

/// <summary>
/// Run this command to generate a report of all vulnerabilities in the project:
/// "dotnet list package --include-transitive --vulnerable --format json >> vulnerability.json"
/// </summary>
public class VulnerabilityScanning : IVulnerabilities
{
    private readonly bool _isWindows;
    private readonly string filename = "nugetVulnerabilities.json";

    public VulnerabilityScanning(bool isWindows)
    {
        _isWindows = isWindows;
    }
    
    public Result<List<Vulnerability>> Scan(string sourcePath)
    {
        if (!Directory.Exists(sourcePath))
        {
            return Result<List<Vulnerability>>.Failed(InitializationFailed.Create());
        }

        var processStartInfo = new ProcessStartInfo
        {
            FileName = _isWindows ? "cmd" : "/bin/bash",
            WorkingDirectory = sourcePath,
            RedirectStandardInput = true,
            RedirectStandardOutput = false,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        var process = Process.Start(processStartInfo)!;
        process.StandardInput.WriteLine("dotnet restore");
        process.StandardInput.WriteLine(
            $"dotnet list package --include-transitive --vulnerable --format json > {filename}");
        process.StandardInput.WriteLine("exit");
        process.WaitForExit();

        var fileStream = File.OpenText($"{sourcePath}/{filename}");
        var records = JsonSerializer.Deserialize<RootAnalysis>(fileStream.ReadToEnd(), new JsonSerializerOptions()
        {
            PropertyNameCaseInsensitive = true
        });
        var vulnerabilities = records!
            .ToVulnarabilties();

        return Result<List<Vulnerability>>.Succeeded(vulnerabilities);
    }
}

public class RootAnalysis
{
    [JsonPropertyName("projects")]
    public List<ProjectRecord> Projects { get; set; }

    public List<Vulnerability> ToVulnarabilties()
    {
        var vulnerabilities = new List<Vulnerability>();

        foreach (var project in Projects)
        {
            foreach (var framework in project.Frameworks)
            {
                vulnerabilities.AddRange(framework.TopLevelPackages
                    .SelectMany(package => package.Vulnerabilities
                        .Select(vulnerability => new Vulnerability()
                        {
                            DependencyName = package.Id,
                            Severity = vulnerability.Severity,
                            Source = vulnerability.Advisoryurl
                        })
                    )
                );
                
                vulnerabilities.AddRange(framework.TransitivePackages
                    .SelectMany(package => package.Vulnerabilities
                        .Select(vulnerability => new Vulnerability()
                        {
                            DependencyName = package.Id,
                            Severity = vulnerability.Severity,
                            Source = vulnerability.Advisoryurl
                        })
                    )
                );
            }
        }

        return vulnerabilities;
    }
}

public class Framework
{
    public List<TopLevelPackage> TopLevelPackages { get; set; }
    public List<TransitivePackage> TransitivePackages { get; set; }
}

public class ProjectRecord
{
    [JsonPropertyName("frameworks")]
    public List<Framework> Frameworks { get; set; }
}

public class TopLevelPackage
{
    public string Id { get; set; }
    public List<VulnerabilityRecord> Vulnerabilities { get; set; }
}

public class TransitivePackage
{
    public string Id { get; set; }
    public List<VulnerabilityRecord> Vulnerabilities { get; set; }
}

public class VulnerabilityRecord
{
    public string Severity { get; set; }
    public string Advisoryurl { get; set; }
}